# 섹션3: 배열과 객체의 성능평가

## 객체를 언제 쓸까?
- 정렬되어 있을 필요가 없을 때
- 값의 접근, 입력, 제거를 빠르게 하고 싶을 때
- + 삽입: O(1)
- + 제거: O(1)
- + 검색: O(N) -> 어떤 정보가 값에 있는지를 확인(모든 필드 확인)
- + 접근: O(1)
- 객체의 시작, 중간, 끝에 값을 집어넣을 수 없다. 단지 key를 통해 접근한다.

## 객체의 주요 메서드와 시간복잡도
`Object.keys` : O(N)
- 객체의 key들을 배열로 반환

`Object.values` : O(N)
- 객체의 value들을 배열로 반환

`Object.entries` : O(N)
- [[키, 밸류], [키, 밸류], ... ] 형태로 반환

`hasOwnProperty` : O(1)
- object.hasOwnProperty('키 이름') 형태로 사용하며 속성이 있는지 여부를 boolean 형태로 반환

## 배열은 언제 쓸까?
- 정렬이 필요할 때
- 맨 마지막에 추가하거나 값을 삭제하는 것은 빠름
- + 삽입: O(1) : 어디에 삽입하는지에 따라 다름
- + - 맨 뒤에 추가할 때(push) : O(1)
- + - 맨 앞에 추가할 때(unshift) : O(N)
- + 제거: O(1) : 어떤 값을 제거하는지에 따라 다름
- + - 맨 마지막 값을 제거할 때(pop) : O(1)
- + - 맨 앞 값을 제거할 때(shift) : O(N)
#### 즉, push, pop 보다 shift, unshift가 훨씬 느리다 (인덱스 새로 정리)
- + 검색: O(N) -> 객체와 동일(모든 엘리먼트 확인)
- + 접근: O(1) -> 객체와 동일

## 배열의 주요 메서드와 시간복잡도
`concat` : O(N)
- 배열끼리 이어붙일 때. array1.concat(array2) 형태로 사용.

`slice` : O(N)
- 배열 일부를 가져옴

`splice` : O(N)
- 배열 일부를 삭제하거나 변경

`sort` : O(N * logN)
- 정렬

`forEach/map/filter/reduce` : O(N)
